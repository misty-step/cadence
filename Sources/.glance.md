### Technical Overview: Cadence Core Sources

The `/Sources` directory contains the implementation of Cadence, a macOS Pomodoro application. The project utilizes a reactive architecture that bridges AppKit’s system-level lifecycle management with SwiftUI’s declarative UI and the modern Swift Observation framework.

#### Architecture and Core Logic
The application is built around a centralized state container, `TimerState`, which serves as the single source of truth for the Pomodoro logic. The architecture follows a delegated pattern: the `AppDelegate` (housed within the app entry point) manages the system-level presence via the macOS menu bar, while a dedicated `WindowManager` encapsulates the configuration and persistence of the floating utility interface. This separation ensures that the core timing logic remains decoupled from the specific windowing and menu bar behaviors of macOS.

#### Key File Roles
- **CadenceApp.swift**: Serves as the application entry point. It configures the app with an `.accessory` activation policy to run without a Dock icon and manages the `NSStatusItem` (menu bar icon). It includes `MenuBarIconImage`, which procedurally generates dynamic `NSImage` assets using `NSBezierPath` to visually represent timer progress directly in the status bar.
- **TimerState.swift**: The primary logic engine. Built using the `@Observable` macro, it manages the countdown `Timer`, tracks session counts, and handles transitions between Focus, Short Break, and Long Break phases. It encapsulates the business rules of the Pomodoro technique, such as triggering long breaks after specific session intervals.
- **TimerView.swift**: The principal SwiftUI interface. It implements a high-contrast UI featuring a circular progress ring, radial gradients for phase-specific styling, and spring-animated interactions. It reacts to changes in `TimerState` to update the countdown display and session indicators.
- **WindowManager.swift**: A controller for the `NSWindow` instance. It manages the lifecycle of a titlebar-less utility panel, configuring it to float above other windows and appear across all Mission Control spaces. It also handles window frame persistence via `setFrameAutosaveName`.
- **NotificationManager.swift**: A wrapper for the `UserNotifications` framework and `NSSound`. It manages user permission requests and triggers system alerts (e.g., "Ping" or "Glass" sounds) when timer phases conclude.

#### Dependencies and Technical Constraints
- **Frameworks**: The application relies on **SwiftUI** for the view layer, **AppKit** for window and status bar management, and the **Observation** framework for state propagation.
- **Status Bar Synchronization**: Due to limitations in observing state changes directly within `NSStatusItem` buttons, the `AppDelegate` implements a 0.5-second polling mechanism to synchronize the procedurally generated menu bar icon with the `TimerState`.
- **Notification Requirements**: The `NotificationManager` requires a valid `Bundle Identifier` to interface with `UNUserNotificationCenter`; the system will fail to deliver alerts if the identifier is missing or misconfigured.
- **Windowing Interop**: The application uses `NSHostingController` to embed the SwiftUI `TimerView` within an AppKit window context. The UI is designed for a fixed-size utility window (380x480) and bypasses standard window decorations to achieve a minimal aesthetic.