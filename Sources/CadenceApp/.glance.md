This directory contains the core implementation of **Cadence**, a macOS Pomodoro-style productivity application. The project follows a reactive architecture, bridging AppKit's lifecycle management with SwiftUIâ€™s declarative UI and the modern Swift Observation framework.

### Architecture and Core Logic
The application is structured around a centralized state container, `TimerState`, which manages the progression of work cycles (Focus, Short Break, and Long Break). It utilizes a delegated architecture where the `AppDelegate` manages the system-level presence (menu bar and lifecycle), while a dedicated `WindowManager` encapsulates the logic for the floating utility window.

### Key File Roles
- **CadenceApp.swift**: The entry point of the application. It configures the app as a macOS accessory (`.accessory` activation policy), allowing it to run without a standard Dock icon. It implements the `NSStatusItem` (menu bar icon) and handles mouse events to toggle the UI or show a context menu. It also includes `MenuBarIconImage`, which procedurally generates dynamic `NSImage` icons using `NSBezierPath` to reflect the current timer phase in the status bar.
- **TimerState.swift**: The primary model and logic engine. Built using the `@Observable` macro, it tracks the remaining time, session counts, and phase transitions. It contains the business logic for the Pomodoro cycle (e.g., triggering a long break after four focus sessions) and manages a background `Timer` for the countdown.
- **TimerView.swift**: The main SwiftUI interface. It features a circular progress ring, high-contrast typography for the countdown, and visual indicators for session completion. It uses `ZStack` and `RadialGradient` for phase-specific background styling and implements custom button interactions with spring animations.
- **WindowManager.swift**: A controller that manages the `NSWindow` instance. It configures the window to be a floating, titlebar-less utility panel that can join all mission control spaces. It handles window persistence via `setFrameAutosaveName` and ensures the window remains within visible screen bounds upon restoration.
- **NotificationManager.swift**: A wrapper for `UserNotifications` and `NSSound`. It handles permission requests and delivers local alerts and system sounds (e.g., "Ping", "Glass") when a timer phase completes.

### Dependencies and Technical Constraints
- **Frameworks**: The app relies on **SwiftUI** for the view layer, **AppKit** for window and status bar management, and the **Observation** framework for state propagation.
- **Status Bar Updates**: Due to the limitations of observing state changes directly within the `NSStatusItem` button, the `AppDelegate` implements a 0.5-second polling mechanism to synchronize the menu bar icon with the `TimerState`.
- **Notification Requirements**: The `NotificationManager` requires a valid `Bundle Identifier` to access the `UNUserNotificationCenter`; it gracefully fails if the identifier is missing.
- **Windowing**: The UI is designed for a fixed-size utility window (380x480). It utilizes `NSHostingController` to embed SwiftUI views within an AppKit window context.